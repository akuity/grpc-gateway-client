package generator

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

const SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

func Generate(p *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	if !hasGatewayCompatibleMethods(file) {
		return nil, nil
	}

	filename := file.GeneratedFilenamePrefix + ".gw.client.go"
	g := p.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-grpc-gateway-client. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)

	for _, svc := range file.Services {
		g.P()
		generateClientInterface(g, svc)
		g.P()
		generateClientConstructor(g, svc)
		g.P()
		generateClientStruct(g, svc)
	}
	return g, nil
}

func generateClientInterface(g *protogen.GeneratedFile, svc *protogen.Service) {
	interfaceName := getClientInterfaceName(svc)
	g.P(fmt.Sprintf("// %s is the interface for %s service client.", interfaceName, svc.GoName))
	g.P(fmt.Sprintf("type %s interface {", interfaceName))
	defer g.P("}")

	for _, method := range svc.Methods {
		if !isGatewayCompatibleMethod(method) {
			continue
		}

		if method.Desc.IsStreamingServer() {
			// StreamingMethod (context.Context, *Request) (<-chan *Response, <-chan error, error)"
			g.P(method.Comments.Leading, method.GoName,
				"(", pkgContext.Ident("Context"), ", *", getMessageIdentifier(method.Input), ") ",
				"(", rpcStreamingReturnType, getMessageIdentifier(method.Output), ", <-chan error, error)",
			)
		} else {
			// UnaryMethod (context.Context, *Request) (*Response, error)"
			g.P(method.Comments.Leading, method.GoName,
				"(", pkgContext.Ident("Context"), ", *", getMessageIdentifier(method.Input), ") ",
				"(", rpcUnaryReturnType, getMessageIdentifier(method.Output), ", error)",
			)
		}
	}
}

func generateClientConstructor(g *protogen.GeneratedFile, svc *protogen.Service) {
	interfaceName := getClientInterfaceName(svc)
	structName := getClientStructName(svc)
	g.P("func New", interfaceName, "(c ", pkgGatewayClient.Ident("Client"), ") ", interfaceName, " {")
	defer g.P("}")

	g.P("return &", structName, " {")
	defer g.P("}")

	g.P("gwc: c,")
}

func generateClientStruct(g *protogen.GeneratedFile, svc *protogen.Service) {
	structName := getClientStructName(svc)
	g.P("type ", structName, " struct {")
	g.P("gwc ", pkgGatewayClient.Ident("Client"))
	g.P("}")
	g.P()
	for _, method := range svc.Methods {
		if !isGatewayCompatibleMethod(method) {
			continue
		}

		if method.Desc.IsStreamingServer() {
			generateStreamingServerMethod(g, structName, method)
		} else {
			generateUnaryMethod(g, structName, method)
		}
		g.P()
	}
}

func generateStreamingServerMethod(g *protogen.GeneratedFile, receiverName string, m *protogen.Method) {
	// func (c *client) StreamingMethod(ctx context.Context, req *Request) (<-chan *Response, <-chan error, error) {"
	g.P("func (c *", receiverName, ") ",
		m.GoName, "(ctx ", pkgContext.Ident("Context"), ", req *", getMessageIdentifier(m.Input), ") ",
		"(", rpcStreamingReturnType, getMessageIdentifier(m.Output), ", <-chan error, error) {")
	defer g.P("}")

	generateParamValues(g, m)
	g.P("return ",
		pkgGatewayClient.Ident("DoStreamingRequest"), "[", getMessageIdentifier(m.Output), "](ctx, c.gwc, gwReq)")
}

func generateUnaryMethod(g *protogen.GeneratedFile, receiverName string, m *protogen.Method) {
	// func (c *client) UnaryMethod(ctx context.Context, req *Request) (*Response, error) {"
	g.P("func (c *", receiverName, ") ",
		m.GoName, "(ctx ", pkgContext.Ident("Context"), ", req *", getMessageIdentifier(m.Input), ") ",
		"(", rpcUnaryReturnType, getMessageIdentifier(m.Output), ", error) {")
	defer g.P("}")

	generateParamValues(g, m)
	g.P("return ",
		pkgGatewayClient.Ident("DoRequest"), "[", getMessageIdentifier(m.Output), "](ctx, gwReq)")
}
